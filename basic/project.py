'''
* Generated by ChatGPT
The Project class is used to represent a Python project, 
and provides methods for loading the project from a remote Git repository 
or from the PyPI package repository, 
analyzing the project's metadata files (setup.cfg and pyproject.toml), 
and outputting information about the project.
'''
import subprocess
import os
from pathlib import Path
import configparser
import logging
import json
from typing import Dict, Any

import urllib3
import toml

PROJECT_ROOT = "/home/tiger1218/dachuang/CodeQL-based-Python-source-code-scanner"
OUTPUT_DIR = "output"
PYPI_MIRROR = "https://pypi.org/project/"

GIT_CLONE = "git clone"


class MetadataNotFoundError(Exception):
    """
    An exception that is raised when a metadata file does not contain a specified key.

    Attributes:
        file_type (str): The type of metadata file (e.g. "setup.cfg", "pyproject.toml").
        key (str): The name of the missing key.

    Methods:
        __str__(): Returns a string representation of the exception, 
            including the file type and key name.
    """
    def __init__(self, file_type, key):
        self.file_type = file_type
        self.key = key

    def __str__(self):
        return f"In file {self.file_type} found not key {self.key}"


class BasicInfoItem:
    """
    A class that represents a basic metadata item for a Python project.

    Attributes:
        key_name (str): The name of the metadata key.
        key_value : The value of the metadata key.
        key_from (str): The source of the metadata key (either "poetry" or "pyproject.toml").

    Methods:
        __str__(): Returns a string representation of the metadata item, including the key name
            , value, and source.
    """
    def __init__(self, key_name: str, key_value: Any, key_from: str) -> None:
        self.key_name = key_name
        self.key_value = key_value
        self.key_from = key_from

    def __str__(self) -> str:
        return f"{self.key_name} = {self.key_value}, from {self.key_from}"


class PythonProject:
    '''
    Class to represent a Python project and its metadata.

    Attributes:
        load_method (str): The method used to load the project, either "git" or "pypi".
        remote_repo (str | None): 
                The remote repository address if using "git" method, otherwise None.
        project_name (str): The name of the project.
        cfg_path (Path | None): The path to the setup.cfg file if it exists, otherwise None.
        pyproject_toml_path (Path | None): 
                The path to the pyproject.toml file if it exists, otherwise None.
        workdir (Path): The working directory of the project.
        key (Dict[str, BasicInfoItem]): 
                A dictionary containing the basic information items of the project.
    '''

    def __init__(self):
        self.load_method: str
        self.remote_repo: str | None
        self.project_name: str
        self.cfg_path: Path | None
        self.pyproject_toml_path: Path | None
        self.workdir: Path
        self.key: Dict[str, BasicInfoItem] = {}

    def load_from_git(self, repo_addr: str) -> None:
        '''
        Load a project from a git repository.

        Args:
            repo_addr (str): The address of the git repository.

        Returns:
            None
        '''
        self.load_method = "git"
        self.remote_repo = repo_addr
        self.project_name = self._parse_remote_repo(repo_addr)

        subprocess.run([GIT_CLONE, repo_addr],
                       shell=True,
                       cwd=Path(PROJECT_ROOT) / OUTPUT_DIR,
                       check=False
                       )

        self.workdir = Path(PROJECT_ROOT) / OUTPUT_DIR / self.project_name

    def load_from_pypi(self, pypi_name: str) -> None:
        '''
        Load a project from PyPI.

        Args:
            pypi_name (str): The name of the package on PyPI.

        Returns:
            None
        '''
        # TODO: Not finish yet.
        # ! Need to implement a lot of things. eg. installation steps by pip.
        self.load_method = "pypi"
        self.remote_repo = PYPI_MIRROR
        self.project_name = pypi_name

        os.chdir(self.project_name)

        self.workdir = Path(PROJECT_ROOT) / OUTPUT_DIR / self.project_name

    def analyze_dir(self) -> None:
        '''
        Analyze the project directory to extract its metadata.

        Raises:
            FileNotFoundError: If the project metadata file cannot be located.

        Returns:
            None
        '''
        flag = 0
        if (self.workdir / "setup.cfg").exists():
            flag = 1
            self.cfg_path = self.workdir / "setup.cfg"
            try:
                self._parse_setup_cfg()
            except MetadataNotFoundError as metadata_error:
                logging.error(metadata_error.__str__)
                flag = 0

        if(self.workdir / "pyproject.toml").exists():
            flag = 1
            self.pyproject_toml_path = self.workdir / "pyproject.toml"
            try:
                self._parse_pyproject_toml()
            except MetadataNotFoundError as metadata_error:
                logging.error(metadata_error.__str__)
                flag = 0

        if not flag:
            raise FileNotFoundError(
                "Cannot locate file indicates project's metadata.")

    def _parse_setup_cfg(self) -> None:
        '''
        Parse the setup.cfg file to extract the project's metadata.

        Raises:
            MetadataNotFoundError: If a required metadata key is not found in the file.

        Returns:
            None
        '''
        cfg_path = self.cfg_path
        rets = []
        metadata_list = ["name", "author", "description", "license"]
        config = configparser.ConfigParser()
        config.read(cfg_path)
        if "metadata" not in config:
            raise MetadataNotFoundError("setup.cfg", "metadata")
        for metadata in metadata_list:
            if not metadata in config['metadata']:
                raise MetadataNotFoundError("setup.cfg", metadata)
            metadata_key_name = self._mapping(metadata)
            basicinfoitem = BasicInfoItem(metadata_key_name,
                                              config['metadata'][metadata],
                                              "setup.cfg"
                                              )
            self.key[metadata_key_name] = [] if self._mapping(metadata) not in self.key \
                        else self.key[metadata_key_name] + basicinfoitem
        return rets

    def _parse_pyproject_toml(self) -> None:
        '''
        Parse the pyproject.toml file to extract the project's metadata.

        Raises:
            MetadataNotFoundError: If a required metadata key is not found in the file.

        Returns:
            None
        '''
        rets = []
        toml_config = toml.load(self.pyproject_toml_path)
        if "tool" in toml_config and "poetry" in toml_config["tool"]:
            # Parse package that use poetry to control project
            metadata_list = ["name", "authors", "description", "license"]
            for metadata in metadata_list:
                if not metadata in toml_config['tool']['poetry']:
                    raise MetadataNotFoundError("pyproject.toml", metadata)
                metadata_key_name = self._mapping(metadata)
                basicinfoitem = BasicInfoItem(metadata_key_name,
                                              toml_config['tool']['poetry'][metadata],
                                              "poetry"
                                              )
                logging.info("Parsed %s", basicinfoitem)
                self.key[metadata_key_name] = [basicinfoitem] if metadata_key_name not in self.key \
                        else self.key[metadata_key_name] + basicinfoitem
        return rets

    def _debug_output(self) -> None:
        '''
        Debugging method to output the attributes of the class.

        Returns:
            None
        '''
        for key in dir(self):
            print(f"key {key} exist", end='')
            if callable(key):
                print('\n')
                continue
            print(f" ,value is {dir(self)[key]}")

    def dump_data(self) -> bool:
        '''
        Dump the metadata of the project in JSON format.

        Returns:
            bool: True if the data was successfully dumped, False otherwise.
        '''
        json_data = json.dumps(self.key,
                               default=lambda o:o. __dict__,
                               sort_keys=True,
                               indent=4)
        print(json_data)

    @staticmethod
    def _parse_remote_repo(repo_addr: str) -> str:
        '''
        Parse the remote repository address to extract the project's name.

        Args:
            repo_addr (str): The address of the git repository.

        Returns:
            str: The name of the project.
        '''
        parser = urllib3.util.parse_url(repo_addr)
        return parser.path.split('/')[-1]

    @staticmethod
    def _mapping(data_name: str) -> str:
        '''
        Map the metadata key names to a standardized format.

        Args:
            data_name (str): The name of the metadata key.

        Returns:
            str: The standardized name of the metadata key.
        '''
        return data_name
