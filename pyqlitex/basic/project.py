'''
* Generated by ChatGPT
The Project class is used to represent a Python project, 
and provides methods for loading the project from a remote Git repository 
or from the PyPI package repository, 
analyzing the project's metadata files (setup.cfg and pyproject.toml), 
and outputting information about the project.
'''
import os
import subprocess
import configparser
import json
import logging
# import os
# import subprocess
import sys
from pathlib import Path
from typing import Any, Dict

import setuptools
import toml
import urllib3
from dotenv import load_dotenv
from humanize import naturalsize

from .exception import MetadataNotFoundError

load_dotenv()
PROJECT_ROOT = os.getenv("PROJECT_ROOT")# "/home/tiger1218/dachuang/PyQLiteX/pyqlitex"
OUTPUT_DIR = os.getenv("OUTPUT_DIR") # output
OUTPUT_JSON_NAME = os.getenv("OUTPUT_JSON_NAME") # demo.json
PYPI_MIRROR = "https://pypi.org/project/"

GIT_CLONE = "git clone"

class BasicInfoItem:
    """
    A class that represents a basic metadata item for a Python project.

    Attributes:
        key_name (str): The name of the metadata key.
        key_value : The value of the metadata key.
        key_from (str): The source of the metadata key (either "poetry" or "pyproject.toml").

    Methods:
        __str__(): Returns a string representation of the metadata item, including the key name
            , value, and source.
    """

    def __init__(self, key_name: str, key_value: Any, key_from: str) -> None:
        self.key_name = key_name
        self.key_value = key_value
        self.key_from = key_from

    def __str__(self) -> str:
        return f"{self.key_name} = {self.key_value}, from {self.key_from}"


class PythonProject:
    '''
    Class to represent a Python project and its metadata.

    Attributes:
        load_method (str): The method used to load the project, either "git" or "pypi".
        remote_repo (str | None): 
                The remote repository address if using "git" method, otherwise None.
        project_name (str): The name of the project.
        cfg_path (Path | None): The path to the setup.cfg file if it exists, otherwise None.
        pyproject_toml_path (Path | None): 
                The path to the pyproject.toml file if it exists, otherwise None.
        workdir (Path): The working directory of the project.
        key (Dict[str, BasicInfoItem]): 
                A dictionary containing the basic information items of the project.
    '''

    def __init__(self, work_dir: str | None = None):
        self.load_method: str
        self.remote_repo: str | None
        self.project_name: str
        self.cfg_path: Path | None
        self.pyproject_toml_path: Path | None
        self.setup_py_path: Path | None
        self.workdir: Path | None = None if not work_dir else Path(work_dir)
        self.key: Dict[str, BasicInfoItem] = {}
        logging.basicConfig(level=logging.ERROR)

    def load_from_git(self, repo_addr: str) -> None:
        '''
        Load a project from a git repository.

        Args:
            repo_addr (str): The address of the git repository.

        Returns:
            None
        '''
        self.load_method = "git"
        self.remote_repo = repo_addr
        self.project_name = self._parse_remote_repo(repo_addr)

        subprocess.run([GIT_CLONE, repo_addr],
                       shell=True,
                       cwd=Path(PROJECT_ROOT) / OUTPUT_DIR,
                       check=False
                       )

        self.workdir = Path(PROJECT_ROOT) / OUTPUT_DIR / self.project_name

    def load_from_pypi(self, pypi_name: str) -> None:
        '''
        Load a project from PyPI.

        Args:
            pypi_name (str): The name of the package on PyPI.

        Returns:
            None
        '''
        # TODO: Not finish yet.
        # ! Need to implement a lot of things. eg. installation steps by pip.
        self.load_method = "pypi"
        self.remote_repo = PYPI_MIRROR
        self.project_name = pypi_name

        os.chdir(self.project_name)

        self.workdir = Path(PROJECT_ROOT) / OUTPUT_DIR / self.project_name

    def analyze_dir(self) -> None:
        '''
        Analyze the project directory to extract its metadata.

        Raises:
            FileNotFoundError: If the project metadata file cannot be located.

        Returns:
            None
        '''
        flag = 0
        if (self.workdir / "setup.cfg").exists():
            flag += 1
            self.cfg_path = self.workdir / "setup.cfg"
            try:
                self._parse_setup_cfg()
            except MetadataNotFoundError as metadata_error:
                logging.error(metadata_error.__str__)
                flag -= 1

        if (self.workdir / "pyproject.toml").exists():
            flag += 1
            self.pyproject_toml_path = self.workdir / "pyproject.toml"
            try:
                self._parse_pyproject_toml()
            except MetadataNotFoundError as metadata_error:
                logging.error(metadata_error.__str__)
                flag -= 1

        if (self.workdir / "setup.py").exists():
            flag += 1
            self.setup_py_path = self.workdir / "setup.py"
            try:
                self._parse_setup_py()
            except MetadataNotFoundError as metadata_error:
                logging.error(metadata_error.__str__)
                flag -= 1

        if not flag:
            raise FileNotFoundError(
                "Cannot locate file indicates project's metadata.")

    def _parse_setup_cfg(self) -> None:
        '''
        Parse the setup.cfg file to extract the project's metadata.

        Raises:
            MetadataNotFoundError: If a required metadata key is not found in the file.

        Returns:
            None
        '''
        cfg_path = self.cfg_path
        metadata_list = ["name", "author", "description", "license"]
        config = configparser.ConfigParser()
        config.read(cfg_path)
        if "metadata" not in config:
            raise MetadataNotFoundError("setup.cfg", "metadata")
        # raise NameError
        for metadata in metadata_list:
            if not metadata in config['metadata']:
                raise MetadataNotFoundError("setup.cfg", metadata)
            metadata_key_name = self._mapping(metadata)
            # print(config['metadata'][metadata])
            basicinfoitem = BasicInfoItem(metadata_key_name,
                                          config['metadata'][metadata],
                                          "setup.cfg"
                                          )
            # print(basicinfoitem.__str__())
            logging.info("Parsed %s", basicinfoitem)
            self.key[metadata_key_name] = [basicinfoitem] \
                if self._mapping(metadata) not in self.key \
                else self.key[metadata_key_name] + basicinfoitem

    def _parse_pyproject_toml(self) -> None:
        '''
        Parse the pyproject.toml file to extract the project's metadata.

        Raises:
            MetadataNotFoundError: If a required metadata key is not found in the file.

        Returns:
            None
        '''
        toml_config = toml.load(self.pyproject_toml_path)

        if "project" in toml_config:
            metadata_list = ["name", "authors", "description", "license"]
            for metadata in metadata_list:
                if not metadata in toml_config['project']:
                    raise MetadataNotFoundError("pyproject.toml", metadata)
                metadata_key_name = self._mapping(metadata)
                basicinfoitem = BasicInfoItem(metadata_key_name,
                                              toml_config['project'][metadata],
                                              "pyproject"
                                              )
                logging.info("Parsed %s", basicinfoitem)
                self.key[metadata_key_name] = [basicinfoitem] if metadata_key_name not in self.key \
                    else self.key[metadata_key_name] + basicinfoitem
        # ! Need to be decoupled
        if "tool" in toml_config and "poetry" in toml_config["tool"]:
            # Parse package that use poetry to control project
            metadata_list = ["name", "authors", "description", "license"]
            for metadata in metadata_list:
                if not metadata in toml_config['tool']['poetry']:
                    raise MetadataNotFoundError("pyproject.toml", metadata)
                metadata_key_name = self._mapping(metadata)
                basicinfoitem = BasicInfoItem(metadata_key_name,
                                              toml_config['tool']['poetry'][metadata],
                                              "poetry"
                                              )
                logging.info("Parsed %s", basicinfoitem)
                self.key[metadata_key_name] = [basicinfoitem] if metadata_key_name not in self.key \
                    else self.key[metadata_key_name] + basicinfoitem

    def _parse_setup_py(self) -> None:
        '''
            Parse the setup.py by monkey patching the setup function.
        '''
        setup_args = None

        def patched_setup(**kwargs):
            setup_args = kwargs

        old_setuptools_setup = setuptools.setup
        setuptools.setup = patched_setup

        sys.path = sys.path + [str(self.workdir)]

        exec(self.setup_py_path.read_text(), {
                "__name__": "__main__",
                "__builtins__": __builtins__,
                "__file__": self.setup_py_path.resolve()})
        setuptools.setup = old_setuptools_setup
        sys.path.pop()
        metadata_list = ["name", "author", "description", "license"]
        for metadata in metadata_list:
            if not metadata in setup_args:
                raise MetadataNotFoundError("setup.py", metadata)
            metadata_key_name = self._mapping(metadata)
            basicinfoitem = BasicInfoItem(metadata_key_name,
                                            setup_args[metadata],
                                            "setup.py"
                                            )
            logging.info("Parsed %s", basicinfoitem)
            self.key[metadata_key_name] = [basicinfoitem] if metadata_key_name not in self.key \
                else self.key[metadata_key_name] + basicinfoitem


    def _debug_output(self) -> None:
        '''
        Debugging method to output the attributes of the class.

        Returns:
            None
        '''
        for key in dir(self):
            print(f"key {key} exist", end='')
            if callable(key):
                print('\n')
                continue
            print(f" ,value is {getattr(self, key)}")

    def dump_data(self, dump_file: None = None) -> int: # TO-DO: return a boolean number
        '''
        Dump the metadata of the project in JSON format.

        Returns:
            int: True if the data was successfully dumped, False otherwise.
        '''
        json_data = json.dumps(self.key,
                               default=lambda o: o. __dict__,
                               sort_keys=True,
                               indent=4)
        try:
            (self.workdir / OUTPUT_DIR).mkdir()
        except FileExistsError:
            pass
        dump_file = dump_file or str(self.workdir / OUTPUT_DIR / "demo.json")
        with open(dump_file, "w+", encoding="utf-8") as f:
            return f.write(json_data)

    def get_size(self) -> str:
        '''
        Return the size of the working dir
        '''
        dir_size = sum(f.stat().st_size for f in self.workdir.glob('**/*') if f.is_file())

        return naturalsize(dir_size, binary=True)

    @staticmethod
    def _parse_remote_repo(repo_addr: str) -> str:
        '''
        Parse the remote repository address to extract the project's name.

        Args:
            repo_addr (str): The address of the git repository.

        Returns:
            str: The name of the project.
        '''
        parser = urllib3.util.parse_url(repo_addr)
        return parser.path.split('/')[-1]

    @staticmethod
    def _mapping(data_name: str) -> str:
        '''
        Map the metadata key names to a standardized format.

        Args:
            data_name (str): The name of the metadata key.

        Returns:
            str: The standardized name of the metadata key.
        '''
        return data_name
